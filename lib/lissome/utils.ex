defmodule Lissome.Utils do
  @doc """
  Turns a module name into a valid Gleam module name.

  Gleam uses `@` to separate paths in module names. For example, a module
  in the directory `src/pages/home` would be compiled as `pages@home`. We process the path to turn it into the correct erlang module name that we can call in Elixir.

  ## Examples:

    iex> Lissome.Utils.format_module_name("nested/nested/nested/mod")
    :nested@nested@nested@mod

    iex> Lissome.Utils.format_module_name("home")
    :home
  """
  def format_module_name(module_path) do
    module_path
    |> Path.split()
    |> Enum.join("@")
    |> String.to_atom()
  end

  @doc """
  Extracts an Erlang record generated by Gleam and creates the corresponding Elixir tuple with the values passed in.

  This function will look for the `.hrl` file by default in the `_{gleam_app_name}/include` directory inside , where `gleam_app_name` is the value of the `:gleam_dir` config in `lissome` or the name of the Gleam app in the `gleam.toml` file if the config is not set. We can pass a fourth argument to specify a different directory. All paths are relative to `{build_path}/lib`.

  Returns a tuple with its first element being the record name and the rest of the elements being the values in the order Erlang expects them. If any of the record keys are not present in the values map, that field will be set to `nil`.

  ## Examples

      iex> flags = %{count: 5, name: "John"}
      # assuming you have a `Flags` type in your Gleam code that expects first
      # the name and then the count
      iex> extract_and_create_record("my_gleam_module", :flags, flags)
      {:flags, "John", 5}

  """
  def extract_and_create_record(module_name, flags_type, values, gleam_dir \\ nil) do
    gleam_dir =
      gleam_dir ||
        case get_gleam_app_from_config() do
          nil -> "_#{extract_gleam_app_name(gleam_dir)}"
          app_name -> "_#{app_name}"
        end

    flags_type_string = flags_type |> Atom.to_string() |> String.capitalize()

    hrl_file_path =
      Path.join([
        gleam_dir,
        "include",
        "#{module_name}_#{flags_type_string}.hrl"
      ])

    flags_type
    |> Record.extract(from_lib: hrl_file_path)
    |> Enum.map(fn {key, _} -> Map.get(values, key) end)
    |> List.to_tuple()
    |> Tuple.insert_at(0, flags_type)
  end

  def json(data), do: Elixir.JSON.encode!(data)

  def get_gleam_app_from_config do
    Application.get_env(:lissome, :gleam_app, nil)
  end

  # replace this with a call to the gleam export package-info
  # command when it's added to gleam
  def extract_gleam_app_name(gleam_dir) do
    content =
      gleam_dir
      |> Path.join("gleam.toml")
      |> File.read!()

    Regex.run(~r/name = "(.*)"/, content) |> List.last()
  end
end
